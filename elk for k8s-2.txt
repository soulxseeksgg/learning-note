kind: StatefulSet //รองรับการใช้ scale ที่ระมัดระวังความเสียหาย

env: //ในไฟล์​ deployment ของ kibana
    value: http://elasticsearch:9200 //คำว่า elasticsearch มาจาก service name ขอ deployment ของ elasticsearch

ตรง image หาจาก
https://www.docker.elastic.co/    

    spec:
      containers:
      - name: kibana
        image: docker.elastic.co/kibana/kibana:7.2.0


kibana ก็ call ได้ 3 แบบ
port-forward
nodePort    
ngx Ingress


kibana call เอาข้อมูลที่อยุ่ใน elasticsearch ผ่านการ call api ไม่ได้ ทำได้แค่เพียงเช็ค status ของแอพอันนี้เทสผ่าน api ได้ แต่การ query ต้องทำผ่านเว็บ
call query
http://localhost:5601/app/kibana

____________         ___________        ________________          _________
| filebeat |  --->> | logstash |  --->> | elasticsearch | --->>  | kibana |
                        

filebeat เก็บ log ให้ logstash ตัด filter จาก  filebeat แล้วส่งออกไป elastichsearh
แล้วให้ kibana ต่อ elasticsearch แล้ว log ที่โดนตัดจะถูกเก็บไว้ใน index

เมนูซ้ายมือ > Dev Tool // query data ของ elasticsearch ทำไว้
           Discover เอาไว้ดู logs แบบ UI แยก logs ให้ไม่ต้องไป query ตรงๆใน dev tool
           Dashboard หรือ Visualizations: ดูแบบกราฟ


ถ้าเป็น deployment ให้ลบ deployment หายเลย ไม่มีขึ้นมาอีก
kubectl delete deployment kibana -n elk
kubectl delete service kibana -n elk

ถ้าเป็นแบบ statefulset ใช้ในของ elasticsearch ที่ไม่ให้มันตายง่าย ต้องลบ statefulset ก่อน
k get all -n elk
k delete statefulset.apps/es-cluster -n elk


 processors:  //บอกว่ามาจาก node ใหน pod ใหน
        - add_kubernetes_metadata:
            host: ${NODE_NAME}
            matchers:
            - logs_path:
                logs_path: "/var/log/containers/"
    
    output.console:
      pretty: true

 input type 
 https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-options.html#filebeat-input-types      



 ## logstash
   basic-logstash.conf: |
    input {

      beats {
        port => 5044
      }

      http {
          port => 8080
          type => "http"
      }

      file {
          path => ["/usr/share/logstash/input/basic-*.log"]
          type => "file"
      }
    }

    filter {
        grok {
            pattern_definitions => {
                "mynumber" => "(?:[+-]?(?:[0-9]+))"
            }

            patterns_dir => ["/usr/share/logstash/pattern"]

            match => {
                "message" => "%{mynumber2:num2}"
            }
        }
            
    }

    output {
        stdout {
        }

        file {
            path => ["/usr/share/logstash/output/basic-%{type}-%{+yyyyMMdd}"]
        }

        elasticsearch {
          hosts => "http://elasticsearch:9200" 
          index => "toon-%{type}-%{+yyyyMMdd}"
        }
    }


#logstash
ทำ mount file จากไฟล์ yaml deployment เข้าไปใน container โดยที่
spec:
  containers:
    - name: logstash
      image: docker.elastic.co/logstash/logstash:7.2.0
      volumeMounts:  //<-------####### เพิ่มตรงนี้ ไส่ภายใต้ image
        - name: logstash-pipeline
          mountPath: /usr/share/logstash/pipeline/logstash.conf  //<-----ชี้เข้าไปใน container
          subPath: pipeline.conf

ใน configMap ให้ ตัวแปร  name: logstash-pipeline  map กับไฟล์ใน yaml เราที่สามารถแก้ไข input filter output ได้จากไฟล์ yaml
 volumes:  <----ไส่ระดับเดียวกับ container
    - name: logstash-pipeline  <<---จากส่วนบน
      configMap:
        name: logstash-config  <<--- ชื่อ configMap

ส่วนของ configMap

apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash-config  <----ชื่อนี้ เอาไปใช้ข้างบน
  namespace: elk
data:
  pipeline.conf: |
    input {
      stdin {}
    }
    filter {
      # Add any filters you want here, e.g., grok, date, etc.
    }
    output {
        elasticsearch {
          hosts => "http://elasticsearch:9200"  //<---ชื่อ service name ของ elasticsearch
        } 
      }         


#filebeat
/usr/share/filebeat/filebeat.yml คือ path ใน container ที่จะใช้เป็นที่เก็บไฟล์ filebeat.yml


data:
  filebeat.yml: |
    filebeat.inputs:
     - type: container
    paths:
      - /var/log/container/*.log
    processors:
      - add_kubernetes_metadata:
          host: ${NODE_NAME}
          matchers:
          - logs_path:
              logs_path: "/var/log/containers/"

    output.elasticsearch:
      hosts: ["http://elasticsearch:9200"]
      index: "filebeat-%{+yyyy.MM.dd}"



plugin for kubernetes vscode
  $ kubectl config get-contexts                                                                                                                                 ✘ 1
  CURRENT   NAME             CLUSTER          AUTHINFO         NAMESPACE
  *         docker-desktop   docker-desktop   docker-desktop
  $ kubectl get nodes
  NAME             STATUS   ROLES           AGE   VERSION
  docker-desktop   Ready    control-plane   26d   v1.30.2
//พร้อม

ค้นหา plugin : Kubernetes (ของ microsoft) 
   จะได้ icon kubernetes ที่เมนูซ้ายมือมา
   จะเจอ node หรือว่า cluster ของเรา

มันกดเข้าไปใน cluster > node > เลือก node เราซึ่งก็คือ docker-desktop กดดูตา มันจะโชว์ resource ด้วยว่าแต่ละตัวใช้ cpu ram เท่าไหร่ ไม่ต้องใช้ metrict





kubectl exec -it pod/logstash-664f86cf4f-zbh9s -n elk -- /bin/sh
echo "xx" | /usr/share/logstash/bin/logstash -f /usr/share/logstash/pipeline/basic-logstash.conf




kubectl exec -it filebeat-589bb7446-67xbn -n elk -- /bin/sh
echo '{"log": "xxxxxxxxxxxxxxxxxxxxxx"}' | filebeat -e 
#debug mode
kubectl exec -it filebeat-7cf669b8c7-258j6 -n elk -- filebeat -e -d "*"


แสดงว่า ถ้าใช้ input แบบ stdin ต้องใช้ คำสั่งที่ตามด้วย filebeat -e เสมอ เพราะมันจะทำให้ Filebeat อ่านข้อมูลจาก stdin ทันทีโดยไม่ต้องใช้คอนฟิกไฟล์หรือทำงานใน background โหมด
-e ย่อมาจากคำว่า "eat the input" หรือ "enable stdout" ซึ่งหมายความว่า Filebeat จะรับข้อมูลจาก stdin และส่งข้อมูลทั้งหมดไปยัง stdout (terminal) แทนที่จะไปเก็บหรือส่งไปยัง output ที่ตั้งค่าในไฟล์คอนฟิก

   
curl -X GET "localhost:9200/_cat/indices?h=index"   

regsitry read current log
/usr/share/filebeat/data/registry/filebeat/data.json


You can have as many inputs as you want but you can in filebeat
Only a single output may be defined

ถ้าใช้ StatefulSet จะใช้ ที่เป็นเลข 0 ต่อท้าย pod ให้ชื่อมันน่ารักๆได้
StatefulSet มักใช้กลับโปรแกรมที่ป้องกันการสูญหายเช่น db ,es


    - type: container
      paths: 
        - '/var/log/containers/*.log'